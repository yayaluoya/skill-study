#### git diff 文件对比

    git diff 对比工作区和暂存区

    git diff --cached 对比暂存区和版本库

    git diff <版本库> 如果指定了版本库就是去对比目标版本库了，没指定就是对比head

    git diff <path> 如果指定了路径的话就只对比改路径的内容

    git diff 命令其实就是用工作区和暂存区去对比目标版本库的。

    这里有注意一个git的重要概念，工作区，暂存区只有一个，版本库有多个；

    只有git diff 命令有点特殊，它是对比工作区和暂存区。

    git diff 命令还可以和其它文件进行比较，因为git的diff命令很强大，所有就可单独作为一个diff工具

    git diff--word-diff 可以逐词比较，默认是逐行进行比较的，逐词进行比较貌似看不出来换行的差异，不过就比较结果而言更加的容易理解,删除内容[-……-]用红色表示，添加的内容{+……+}用绿色表示

#### git blame 文件追溯

    逐行显示文件，在每一行的行首显示此行最早是在什么版本引入的，由谁引入的。

    就是查看某个文件的版本变更历史

    git blame <path> 查看某个文件的版本变更历史

    git blame -L 6,+5 <path> 只查看文件某几行的变更历史

#### git bisect 二分查找

    当当前版本出现bug，需要找出这个bug是什么时候出来的时，你可能需要这么做，一次次的往上一个版本跳，然后检查有没有这个bug，显然这种操作非常耗时，万一第一个版本就有这个bug了呢。如果聪明的话就使用二分查找的方法，这也是生活中常用的方法。就是先找到上一个正常的版本，然后定位到两个版本的中间版本，如果这个版本是正确的那么错误版本就一定在这个中间版本和当前错误版本之间，这不就一次性排除了一半的版本了吗，然后继续重复此操作，不就能很快速的找到错误版本了吗

    git bisect 这个命令就是刚刚说的聪明做法的简单命令。

    git bisect start 开始

    git bisect bad [c] 将目标版本或当前定位的版本标记为坏提交

    git bisect good [c] 将目标版本或当前定位的版本标记为好提交

    此时就会自动定位到 当前标记的好坏提交的中间提交

    git bisect reset 当最终找到的目标提交后，此次二分查找就结束了，使用此命令撤销二分查找在版本库中遗留的临时文件和引用。撤销二分查找后，版本库切换回执行二分查找之前所在的分支。

    如果中间出现了标记错误的操作，则可以用git bisect log命令查看二分查找的日志记录，把二分查找的日志保存在一个文件中，git bisect log＞logfile，编辑这个文件，删除记录了错误动作的行。结束正在进行的出错的二分查找。git bisect reset，通过日志文件恢复进度，重启二分查找。git bisect replay logfile 然后就重新回到了刚刚出错时的提交

    git bisect run 自动化，这样查找问题就更方便了，就更爽了。具体看文档

#### git ls-tree 

    查看历史版本的目录树，其实还有用git cat-file <c> -p 查看某次提交的信息，然后就能看到此次提交的目录树id，然后再用 git cat-file 命令就能看到这个目录树的内容了。

#### git 悔棋的操作

    用git commit --amend 命令，就能重新建一个提交，来覆盖当前的提交。注意并不是修改上一个提交的内容，而是新建的一个提交，因为这样的话连这个提交修改都是记录在案的，符合版本管理的思想。

#### git 的提交合并操作

    其实就是用reset命令加--soft参数重置版本库目录树但不改变工作区和暂存区的内容，然后再重新提交。

#### git cherry-pick <c> 应用一个提交在到当前的工作分支中

    注意是应用一个或多个提交，相当于在当前工作分支中创建一个或多个和目标提交一致的提交，这些提交是对目标提交进行克隆的，而不是直接使用的，它们除了提交说明，和提交用户一样其它的都不一样，连目录树id都不一样，目录树内容也不一样。因为它是基于父提交的一个补丁，然后应用在本次工作分支只上生成的一个新提交。

    为何会冲突：用 diff 工具生成 patch 时，我们所做的每一处修改都会连同它的“定位信息”（原始文件中的行号、修改处前三行和后三行的原始文本）一并保存到 patch 文件中。patch 被应用时，会在目标文件中寻找“定位信息”，找到后再实施修改。可是，当我们把补丁应用到 当前分支 上时，有可能找不到那些定位信息了，于是应用patch失败，即发生冲突。

#### git rebase 对提交执行变基操作，即可以实现将指定范围的提交“嫁接”到另外一个提交之上

    命令格式:git rebase--onto＜newbase＞＜since＞＜till＞

    命令执行步骤：
        1 执行git checkout切换到＜till＞。注意：因为会切换到＜till＞，因此如果＜till＞指向的不是一个分支（如master），则变基操作是在detached HEAD（分离头指针）状态进行的。
        2 将＜since＞..＜till＞所标识的提交范围写到一个临时文件中。注意这个范围是（since,till]
        3 将当前分支强制重置（git reset--hard）到＜newbase＞。
        4 从保存在临时文件中的提交列表中，将提交逐一按顺序重新提交到重置之后的分支上。
        5 如果遇到提交已经在分支中包含，则跳过该提交。
        6 如果在提交过程遇到冲突，则变基过程暂停。用户解决冲突后，执行git rebase--continue继续变基操作。或者执行git rebase--skip跳过此提交。或者执行git rebase--abort就此终止变基操作切换到变基前的分支上。

#### git rebase --onto＜newbase＞＜since＞＜till＞ -i 交互式变基，执行交互式变基操作，会将＜since＞..＜till＞的提交悉数罗列在一个文件中，然后自动打开一个编辑器来编辑这个文件。可以通过修改文件的内容设定变基操作，实现删除提交、将多个提交压缩为一个提交、更改提交的顺序，以及更改历史提交的提交说明等。

#### 今天还学习了一下vi/vim的用法，其实之前也会一点但是一直搞不懂原理所在，今天算是彻底搞懂了。