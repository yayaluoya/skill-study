## 声明合并

#### 超级重要的东西
TypeScript中的声明会创建以下三种实体之一：命名空间，类型或值。 创建命名空间的声明会新建一个命名空间，它包含了用（.）符号来访问时使用的名字。 创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。 最后，创建值的声明会创建在JavaScript输出中看到的值。

DeclarationType	Namespace	Type	Value
Namespace	    X		            X     - 注意只有命名空间包含了命名空间的实体
Class		                X	    X
Enum		                X	    X
Interface		            X	
Type Alias (类型别名)		            X	
Function			                X
Variable（变量）			         X

#### 了解各个类型的声明是怎么合并的

命名空间可以与其它类型的声明进行合并。（可以用它来扩展其它类型）

#### 非法的合并
TypeScript并非允许所有的合并。 目前，类不能与其它类或变量合并。 想要了解如何模仿类的合并，请参考 TypeScript的混入。

#### 模块扩展

虽然JavaScript不支持合并，但你可以为导入的对象打补丁以更新它们。

模块名的解析和用 import/ export解析模块标识符的方式是一致的（所以相对路径和非相对路径都可以）。 更多信息请参考 Modules。 当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。

需要注意的是模块扩展的必须写在模块模式的文件中才能扩展，不然就是覆盖。（非常重要的细节，这样也确实比较合理）

#### 关于声明 declare

声明的 global 是全局的 且不受模块模式的影响
声明的带引号的模块是全局的 且不受模块模式的影响（如果是扩展的话会有影响，但全局的特性不会受到影响）

其它的看文件模式，如果是脚本模式的话就是全局的

#### 关于模块模式的声明合并

多个模块之间是不存在声明合并了，因为如果使用的是模块模式，就表示所有声明都是局部作用域的了，原则上就不存在声明合并
所以 只有全局的声明才会合并同名声明，或者一个文件中的同名声明才会以对应的方式合并

## tsx

TypeScript在.tsx文件里禁用了使用尖括号的类型断言（因为会有写法冲突）。

## 装饰器

多个装饰器可以同时应用到一个声明上，就像下面的示例：

书写在同一行上：
@f @g x
书写在多行上：
@f
@g
x

当多个装饰器应用于一个声明上，它们求值方式与复合函数相似。在这个模型下，当复合f和g时，复合的结果(f ∘ g)(x)等同于f(g(x))。

装饰器求值
类中不同声明上的装饰器将按以下规定的顺序应用：

参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。
参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。
参数装饰器应用到构造函数。
类装饰器应用到类。