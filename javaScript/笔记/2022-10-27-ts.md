#### 交叉类型 &

交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。

#### 联合类型 | 

联合类型表示一个值可以是几种类型之一。

如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。

#### 类型保护

类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词
谓词为 parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。
TypeScript可以将typeof v === "typename"和 typeof v !== "typename"识别为一个类型保护，"typename"必须是 "number"， "string"， "boolean"或 "symbol"。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。
instanceof 关键字也具有类型保护功能
instanceof类型保护是通过构造函数来细化类型的一种方式。
instanceof的右侧要求是一个构造函数，TypeScript将细化为：
    此构造函数的 prototype属性的类型，如果它的类型不为 any的话
    构造签名所返回的类型的联合
以此顺序。


--strictNullChecks标记可以解决null与 undefined可以赋值给任何类型的错误：当你声明一个变量时，它不会自动地包含 null或 undefined。 你可以使用联合类型明确的包含它们
使用了 --strictNullChecks，可选参数会被自动地加上 | undefined:

#### !后缀
使用identifier!从 identifier的类型里去除了 null和 undefined
相当与语法!后缀可以去除类型里面的null|undefined

#### 类型别名

类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。
起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。
同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入
我们也可以使用类型别名来在属性里引用自己（这样就能实现递归）
类型别名不能再右侧被作为泛型参数来传递，应为这样没有意义

#### 接口 vs. 类型别名

其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。

另一个重要区别是类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）。 因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。（重要，对于不能扩展可能是它比较自由吧，可操作性很高，所以不好像接口和类一样规范）

#### 枚举成员类型
如我们在 枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。

在我们谈及“单例类型”的时候，多数是指枚举成员类型和数字/字符串字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。

#### 可辨识联合（Discriminated Unions）
你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：

具有普通的单例类型属性— 可辨识的特征。
一个类型别名包含了那些类型的联合— 联合。
此属性上的类型保护。

#### 多态的 this类型

多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承。（注意这个连贯性，及时是基础的某个类，它的this类型也能延续下去，不用重新定义返回值类型或一些其它类型）

#### 索引类型查询操作符 keyof T

对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。

#### 索引访问操作符 T[K]

在这里，类型语法反映了表达式语法。 这意味着 person['name']具有类型 Person['name'] — 在我们的例子里则为 string类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 T[K]，这正是它的强大所在。 你只要确保类型变量 K extends keyof T就可以了。

想要通过索引获取某个属性类型只能通过这个操作符

#### 类型映射

它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分：

类型变量 K，它会依次绑定到每个属性。
字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。
属性的结果类型。