#### 引用
垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

#### 引用计数垃圾收集
这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

### 限制：循环引用
```js
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();

```
该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

#### 标记 - 清除算法
这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。

#### 循环引用不再是问题了
在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。

#### 限制：那些无法从根对象查询到的对象都将被清除
尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。

#### 执行时机

JavaScript 的垃圾回收（Garbage Collection，GC）是自动进行的，其目的是释放不再使用的内存，以便为其他数据结构腾出空间。垃圾回收的确切时间点并不固定，由 JavaScript 引擎的垃圾回收器（Garbage Collector）根据内存使用情况和内部算法来决定。以下是一些关于 JavaScript 垃圾回收执行时机的要点：

1. **无用内存的识别**：垃圾回收器会定期检查内存中的对象，识别出那些不再被任何变量引用的对象。这些对象被认为是“无用的”，即它们无法再被访问。

2. **标记-清除算法**：许多垃圾回收器使用标记-清除算法。这个过程通常分为两个阶段：首先，垃圾回收器会遍历所有活跃的对象（即被引用的对象），并标记它们。然后，它会清除所有未被标记的对象，这些对象就是无用的。

3. **分代收集**：现代 JavaScript 引擎（如 V8，SpiderMonkey）通常采用分代垃圾回收策略。它们将对象分为不同的“代”，根据对象的生命周期将它们存储在不同的地方。新创建的对象通常被分配在“新生代”，经过一定时间后，如果对象仍然存活，它们会被移动到“老生代”。不同代的对象会以不同的频率进行垃圾回收。

4. **并发与并行**：为了提高性能，垃圾回收器可能会并发地（与 JavaScript 代码同时运行）或并行地（多个核心同时工作）执行垃圾回收任务。

5. **内存压力**：当内存使用接近上限时，垃圾回收器更可能执行垃圾回收，以释放内存空间。

6. **调用 API**：在某些情况下，开发者可以通过调用特定的 API 来提示垃圾回收器运行，例如在 Node.js 中的 `global.gc()`（不推荐使用，因为它可能会影响性能）。

7. **自动触发**：大多数情况下，垃圾回收是自动触发的，开发者不需要手动管理。

8. **性能影响**：垃圾回收是一个重量级操作，可能会暂时阻塞 JavaScript 代码的执行。因此，垃圾回收器会尝试在不影响用户体验的情况下执行。

由于垃圾回收的具体时机是由 JavaScript 引擎内部的算法决定的，开发者通常无法精确控制。然而，可以通过编写高效的代码和避免内存泄漏来减少垃圾回收的频率和影响。
