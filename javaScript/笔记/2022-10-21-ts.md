#### 类

在TypeScript里，成员都默认为 public。

TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。

然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。

constructor方法如果是private的则不能在外部实例化该类并且不能被继承了
如果想要外部不能实例化并且能被继承的话则要把construtor修饰成protected

- readonly 修饰符

    把某个属性标记成只读了，只能在声明时和constructor中被初始化，这意味着可以接受外部的参数
    注意只能标记属性和索引签名，不能标记方法

在constructor方法的参数中可以声明属性，这样就能避免声明和在构造函数中初始值出现重复定义了，非常推荐这种写法

- 存取器

    只带有 get不带有 set的存取器自动被推断为 readonly。这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。

- abstract 抽象类

    抽象类中能包含定义和实现
    不能和static一起使用
    - 和接口的区别
      - 接口只能包含定义，不能包含实现
      - 接口只能定义public的属性，除非继承class，不然不能包含private和protected修饰的属性

- 把类当做接口使用

    如果类成员中含有非public的访问修饰符的话，这个接口就只能被这个类的子类implements了

#### typeof

    注意如果是类的话是获取类的静态类型，而不是实例类型，要区分类的静态类型和实例类型