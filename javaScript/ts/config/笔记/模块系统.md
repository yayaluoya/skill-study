# 模块系统

任何通过为文件提供自己的范围来解决此问题的系统，同时仍然提供一种使代码段可供其他文件使用的方法，都可以称为“模块系统”。 （模块系统中的每个文件都称为“模块”，这听起来似乎很明显，但该术语通常用于与脚本文件进行对比，脚本文件在全局范围内运行在模块系统之外。）

详细看 [文档](https://ts.nodejs.cn/docs/handbook/modules/theory.html)

## 模块输出格式

在任何项目中，我们需要回答的关于模块的第一个问题是宿主期望什么类型的模块，因此 TypeScript 可以为每个文件设置其输出格式以匹配。有时，宿主仅支持一种模块 - 例如，浏览器中的 ESM，或 Node.js v11 及更早版本中的 CJS。Node.js v12 及更高版本接受 CJS 和 ES 模块，但使用文件扩展名和 package.json 文件来确定每个文件应采用的格式，如果文件内容与预期格式不匹配，则会抛出错误。

module 编译器选项向编译器提供此信息。它的主要目的是控制编译期间触发的任何 JavaScript 的模块格式，但它也用于通知编译器应如何检测每个文件的模块类型，如何允许不同的模块类型相互导入，以及 import.meta、顶层 await 等功能是否可用。因此，即使 TypeScript 项目使用 noEmit，为 module 选择正确的设置仍然很重要。正如我们之前所建立的，编译器需要准确理解模块系统，以便它可以对导入进行类型检查（并提供 IntelliSense）。有关为你的项目选择正确的 module 设置的指南，请参阅 选择编译器选项。

可用的 module 设置为

- node16：反映了 Node.js v16+ 的模块系统，它同时支持 ES 模块和 CJS 模块，并具有特定的互操作性和检测规则。
- node18：反映了 Node.js v18+ 的模块系统，它增加了对导入属性的支持。
- nodenext：随着 Node.js 模块系统的发展，移动目标反映了最新的 Node.js 版本。从 TypeScript 5.8 开始，nodenext 支持 ECMAScript 模块的 require。
- es2015：反映 JavaScript 模块的 ES2015 语言规范（首次将 import 和 export 引入该语言的版本）。
- es2020：在 es2015 中添加了对 import.meta 和 export * as ns from "mod" 的支持。
- es2022：添加对顶层 await 至 es2020 的支持。
- esnext：目前与 es2022 相同，但将是一个移动目标，反映最新的 ECMAScript 规范以及与模块相关的 Stage 3+ 提案，预计将包含在即将推出的规范版本中。
- commonjs、system、amd 和 umd：每个都会触发指定模块系统中的所有内容，并假设所有内容都可以成功导入到该模块系统中。这些不再推荐用于新项目，并且本文档也不会详细介绍。

注意事项：

Node.js 的模块格式检测和互操作性规则使得对于在 Node.js 中运行的项目将 module 指定为 esnext 或 commonjs 是不正确的，即使 tsc 触发的所有文件分别是 ESM 或 CJS。对于打算在 Node.js 中运行的项目，唯一正确的 module 设置是 node16 和 nodenext。虽然全 ESM Node.js 项目触发的 JavaScript 在使用 esnext 和 nodenext 的编译之间可能看起来相同，但类型检查可能有所不同。有关详细信息，请参阅 nodenext 的参考部分。

## 模块格式检测

Node.js 可以理解 ES 模块和 CJS 模块，但每个文件的格式由其文件扩展名以及在文件目录和所有祖级目录搜索中找到的第一个 package.json 文件的 type 字段决定：

- .mjs 和 .cjs 文件始终分别解释为 ES 模块和 CJS 模块。
- 如果最近的 package.json 文件包含值为 "module" 的 type 字段，则 .js 文件将被解释为 ES 模块。如果没有 package.json 文件，或者 type 字段丢失或具有任何其他值，则 .js 文件将被解释为 CJS 模块。

如果通过这些规则确定文件是 ES 模块，Node.js 在评估期间不会将 CommonJS module 和 require 对象注入到文件的作用域中，因此尝试使用它们的文件将导致崩溃。相反，如果某个文件被确定为 CJS 模块，则该文件中的 import 和 export 声明将导致语法错误崩溃。

当 module 编译器选项设置为 node16、node18 或 nodenext 时，TypeScript 会将相同的算法应用于项目的输入文件，以确定每个相应输出文件的模块类型。让我们看看如何在使用 --module nodenext 的示例项目中检测模块格式：

| 输入文件名                      | 内容   | 输出文件名      | 模块种类 | 原因                     |
|---------------------------------|--------|-----------------|----------|--------------------------|
| /package.json                   | {}     |                 |          |                          |
| /main.mts                       |        | /main.mjs       | ESM      | 文件扩展名               |
| /utils.cts                      |        | /utils.cjs      | CJS      | 文件扩展名               |
| /example.ts                     |        | /example.js     | CJS      | package.json 中没有 "type": "module" |
| /node_modules/pkg/package.json  | { "type": "module" } |                 |          |                          |
| /node_modules/pkg/index.d.ts    |        |                 | ESM      | package.json 中的 "type": "module" |
| /node_modules/pkg/index.d.cts   |        |                 | CJS      | 文件扩展名               |
