#### 命令的执行过程

(交互式情况下) 接收用户输入，直到检测到用户输入回车。

查找命令。 如果不含有斜线/，说明不是文件形式，进一步查找到内置命令。查找顺序是由内到外的：运行环境中的函数或别名、shell 中的内置命令、PATH 变量路径集合下的外部命令。

#### 命令的参数

语法上，命令之后都会被解析为参数，默认以空格为分隔符。
以 - 或 -- 开头的参数称为选项（option），其它称为非选项（non-option）或操作数。
结构类型上，选项可以分为标志型和键-值对型。键-值对的写法有 --key value ，--key=value
短选项可以组合，-ab 等同 -a -b。短选项与值直接的空白是可选的，-afoo 等同 -a foo。
选项一般放在非选项之前。-- 用于表示所有选项结束，后面都是非选项，比如 --foo -- --bar,--foo 是选项，--bar 是非选项。

#### 命令的退出状态码

命令执行退出时会带有一个状态码（exit status code），范围为 0-255，表示命令执行成功与否，0 表示执行成功，非零表示执行失败。
变量 $? 记录了上一条命令的状态码。
false # 命令 true 和 false 单纯返回状态码 0 和 1
echo $?

#### 命令的语法文档

其中用到了许多具有特定意义的符号：

[] 表示可选的部分，可以嵌套。
| 表示左右两边互斥。
< > 表示需要被实际内容替换的部分。
... 表示可以存在多个值。

#### ; 顺序执行

命令有两种结束标志: 换行和分号 ; 。 使用 ; ，可以做到在一行内编写多个命令,这也可以实现在终端一次性键入多个命令。
command1; command2; command3
复制代码
需要注意的是，命令的顺序执行，不会因为出错而终止。也就是说，即使上一条命令执行失败了（退出码非 0），后面的命令也会按序执行。

#### && 逻辑与

&& 把几个命令通过与逻辑组合在一起，只有前面的命令成功执行，才执行后面的命令，是最常用的命令组合方式。 #只有当目录创建成功时，才切换到该目录
mkdir my-folder && cd my-folder
复制代码
运用 && 运算符能方便地实现条件执行，类似 if ... then ...。

#### || 逻辑或

与 && 相反，|| 表示的是或逻辑，只有当前面的命令执行失败时，才执行后面的命令。

结合 && 与 || 可以写出 if...else 结构：

true && echo true || echo false
#true

#### & 后台执行

在命令后添加运算符 & 表示启动一个子 shell 进程在后台异步执行这个命令，结果输出到当前 shell。
& 也可以拼接命令。
command1 & command2 & command3 # 命令 1，2 在后台运行，3 在前台运行
复制代码
这种形式可以用来同时启动多个任务。

#### 查看环境变量

可以通过 printenv 命令查看环境变量：
printenv PATH

# /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/puppetlabs/bin

复制代码

💡 PATH 变量记录了一组目录，当 shell 解析到一个外部命令时，会到这些目录下查找对应的可执行文件。

也可以直接 echo $name 查看。

#### Glob 模式 这个超级常见

大括号和文件名展开是一种很方便的文件匹配方法，它有一个名称叫 glob。
Glob 在很多语言和工具中都有应用，比如 gitignore 文件，ESLint 配置。
常见的通配符和模式有：

通配符或模式含义和例子
_匹配任意字符串（含空串），但是不能跨越目录层级。
\*\* 匹配任意层级目录。
?匹配一个字符。
[abc]匹配中括号内的字符集合中的一个。排除法用 [^abc] 或 [!abc]，还可以匹配范围[0-9]。
a{b,c_}d 先展开成模式 abd，ac\*d，再分别匹配，只要能满足一个就算匹配。
{start..end}会匹配连续范围的字符

glob 和正则表达式容易混淆，二者虽然都是模式匹配的工具，但通配符的含义却是完全不同的。 Glob 是专用于匹配文件名的，而正则是一种更通用的字符串匹配工具。

#### 重定向输出

使用 > 把命令的输出重定向到文件：
ls > files.txt
复制代码
如果文件不存在，会创建该文件，所以可以用来很方便地创建一个小文件：
echo "{}" > config.json
复制代码
如果文件存在，则会先清空再写入。如果希望保留文件原内容，从文件末添加（append），可以使用 >>:
ls >> files.txt

#### 重定向输入

重定向输入用 < 。输入重定向用得比较少，大部分情况都是直接支持用文件做参数。
下面的 read-print.sh 从标准输入读取输入，并打印
#!/bin/bash
read var;
echo $var;
复制代码
重定向标准输入，把一个文件内容作为输入：
bash read-print.sh < files.txt

#### Shebang 指令 超级重要（译作释伴，意思是解释伴执行）

脚本的第一行以 #! 开始，称为 shebang 指令,用于指定运行该脚本的解析器。
当一个文件被执行时，计算机会先判断它是否是一个二进制文件，如果不是，就调用 shebang 指令指定的解析器执行该文件。
如果没有解析到 shebang，默认使用 /bin/sh。
如果是显式调用解析器执行脚本（见下），则 shebang 指令会被忽略不起作用。
Shebang 指令是所有脚本语言通用的。在 JS 与 Python 中，一般写成:
#JS 脚本中
#!/usr/bin/env node

#PY3 脚本中
#!/usr/bin/env python3
复制代码
因为这些解析器的安装环境不确定， /usr/bin/env 命令可以找到系统中的安装路径，是一种兼容性更佳的写法。

更多详情直接百度 shebang
